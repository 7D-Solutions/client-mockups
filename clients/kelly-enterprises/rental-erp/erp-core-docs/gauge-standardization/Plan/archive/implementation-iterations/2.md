# Gauge Set System - Complete Implementation Plan

**Status**: Ready for Implementation
**Phase**: Development (Breaking Changes Allowed)
**Date**: October 2024

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Current State Analysis](#current-state-analysis)
3. [Root Cause Analysis](#root-cause-analysis)
4. [Clean-Slate Architecture](#clean-slate-architecture)
5. [Database Migration (Corrected)](#database-migration-corrected)
6. [Domain Model Design](#domain-model-design)
7. [Repository Pattern](#repository-pattern)
8. [Service Layer](#service-layer)
9. [Implementation Roadmap](#implementation-roadmap)
10. [Acceptance Criteria](#acceptance-criteria)
11. [Migration Strategy](#migration-strategy)

---

## Executive Summary

### Critical Issues Identified

1. **Complete System Failure**: NO gauge sets exist in production database
   - All `companion_gauge_id` fields are NULL
   - All `gauge_suffix` fields are NULL
   - GO/NO GO distinction completely non-functional

2. **Root Causes**:
   - Transaction boundary violations in repository layer
   - Missing field population in service layer
   - Architectural confusion in dual-mode methods

3. **Solution**: Clean-slate architecture with:
   - Corrected database constraints and triggers
   - Domain-driven design with GaugeSet aggregate
   - Explicit transaction passing pattern
   - Service layer orchestration

### Key Architectural Decisions

1. **Explicit Transactions**: All write methods REQUIRE connection parameter
2. **Domain-Driven**: Business rules enforced in domain objects
3. **Database Constraints**: Simple validation only (no impossible constraints)
4. **Fail Fast**: Invalid states prevented at domain and database levels
5. **Single Responsibility**: Each layer has ONE job

---

## Current State Analysis

### Database Reality

**Evidence from `db_export_20251021_212300.sql`**:

```sql
-- Example gauge record (line 1568):
INSERT INTO gauges VALUES
  (1568, 'SP0001', NULL, '.312-18 2A RING', 'thread_gauge',
   'JOE25022', 41, 'available', NULL, 0, ..., NULL, 'SP0001', NULL, ...)
   --                                                  ^^^^           ^^^^
   --                                      companion_gauge_id=NULL  gauge_suffix=NULL
```

**Finding**: 100% of gauges have NULL companion relationships and NULL suffixes.

### Implementation Status

| Component | Completeness | Status |
|-----------|--------------|--------|
| Database Schema | 95% | Fields exist but no constraints |
| Backend API Endpoints | 70% | Routes exist but broken logic |
| Backend Services | 80% | Logic exists but transaction bugs |
| Frontend Components | 40% | Basic UI, missing workflows |

### Gap Analysis

**Missing Functionality**:
- ❌ Spare Inventory UI
- ❌ Pair Spares workflow
- ❌ Replace Gauge workflow
- ❌ Companion History display

**Broken Functionality**:
- ❌ Gauge set creation (creates orphans instead)
- ❌ GO/NO GO distinction (no suffix population)
- ❌ Companion linking (transaction boundary violation)

---

## Root Cause Analysis

### Bug 1: Transaction Boundary Violation

**Location**: `backend/src/modules/gauge/repositories/GaugeRepository.js:934-943`

**The Problem**:
```javascript
async updateCompanionGauges(gaugeId1, gaugeId2, conn) {
  const connection = conn || await this.getConnectionWithTimeout();
  // ... validation logic ...

  // ❌ CRITICAL BUG: Missing connection parameter
  await this.executeQuery(
    'UPDATE gauges SET companion_gauge_id = ? WHERE id = ?',
    [gaugeId2, gaugeId1]
    // Should be: [gaugeId2, gaugeId1], connection
  );

  await this.executeQuery(
    'UPDATE gauges SET companion_gauge_id = ? WHERE id = ?',
    [gaugeId1, gaugeId2]
    // Should be: [gaugeId1, gaugeId2], connection
  );
}
```

**Why This Breaks**:
```javascript
// BaseRepository.executeQuery (lines 524-558):
async executeQuery(query, params = [], conn) {
  const connection = conn || await this.getConnectionWithTimeout();
  //                  ^^^^
  // Without conn parameter, gets NEW connection from pool!
  // This breaks transaction isolation!
}
```

**Impact**: Updates execute on different connection → outside transaction scope → rollback doesn't affect companion updates → orphaned gauges created.

### Bug 2: Missing `gauge_suffix` Population

**Location**: `backend/src/modules/gauge/services/GaugeCreationService.js:266-290`

**The Problem**:
```javascript
const goGaugeWithId = {
  ...goGaugeData,
  system_gauge_id: `${baseId}A`,  // String contains 'A'
  gauge_id: `${baseId}A`,
  companion_gauge_id: null,
  // ❌ MISSING: gauge_suffix: 'A'
  created_by: userId
};

const noGoGaugeWithId = {
  ...noGoGaugeData,
  system_gauge_id: `${baseId}B`,  // String contains 'B'
  gauge_id: `${baseId}B`,
  companion_gauge_id: null,
  // ❌ MISSING: gauge_suffix: 'B'
  created_by: userId
};
```

**Impact**:
- No GO/NO GO distinction at database level
- Inefficient queries (must parse strings instead of indexed suffix column)
- Violates normalization (data encoded in string)

### Bug 3: Architectural Ambiguity

**Problem**: Methods try to be dual-purpose (standalone + transactional)

```javascript
async updateCompanionGauges(gaugeId1, gaugeId2, conn) {
  const connection = conn || await this.getConnectionWithTimeout();
  //                  ^^^^ Who owns this transaction?
}
```

**Confusion**:
- If `conn` provided → use it (part of larger transaction)
- If `conn` not provided → create own transaction
- Violates Single Responsibility Principle
- Unclear transaction ownership

---

## Clean-Slate Architecture

### Design Principles

1. **Explicit Over Implicit**: Transaction boundaries must be obvious
2. **Fail Fast**: Invalid states prevented at database level
3. **Domain-Driven**: Business logic in domain objects, not scattered
4. **Single Responsibility**: Each layer has ONE job
5. **Type Safety**: Domain objects enforce invariants

### Architecture Layers

```
┌─────────────────────────────────────────────────────┐
│                  Frontend (React)                    │
│  - CreateGaugeWorkflow.tsx                          │
│  - GaugeSetDisplay.tsx                              │
│  - SpareInventoryPanel.tsx                          │
└──────────────────────┬──────────────────────────────┘
                       │ REST API
┌──────────────────────▼──────────────────────────────┐
│              Service Layer                           │
│  - GaugeSetService (orchestrates transactions)      │
│  - Validates business rules                         │
│  - Manages transaction lifecycle                    │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│              Domain Model                            │
│  - GaugeSet (aggregate root)                        │
│  - GaugeEntity (value object)                       │
│  - Enforces invariants                              │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│           Repository Layer                           │
│  - GaugeRepository (data access only)               │
│  - ALL write methods REQUIRE connection             │
│  - NO transaction management                        │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│               Database Layer                         │
│  - Constraints enforce data integrity               │
│  - Triggers maintain consistency                    │
│  - Foreign keys enforce relationships               │
└─────────────────────────────────────────────────────┘
```

---

## Database Migration (Corrected)

**File**: `002_gauge_set_constraints_CORRECTED.sql`

### Critical Corrections Made

**Investigation Findings** (independently verified):
1. ❌ **Bidirectional companion CHECK constraint is architecturally impossible** (chicken-and-egg problem)
2. ❌ **NULL in suffix constraint ineffective** (`gauge_suffix IN ('A', 'B', NULL)` allows NULL)
3. ⚠️ **Bidirectional trigger has recursion risk** in complex scenarios

### Corrected Migration Script

```sql
-- ============================================================================
-- Migration: 002_gauge_set_constraints_CORRECTED.sql
-- Purpose: Add safe constraints, triggers, and indexes for gauge set system
-- Status: READY FOR DEPLOYMENT
-- Date: October 2024
-- IMPORTANT: Corrected version - fixes critical flaws in original proposal
-- ============================================================================

-- ----------------------------------------------------------------------------
-- PHASE 1: SAFE CHECK CONSTRAINTS
-- ----------------------------------------------------------------------------

-- Constraint: Thread gauges must have valid suffix (A or B, NOT NULL)
-- CORRECTED: Removed NULL from allowed values
ALTER TABLE gauges ADD CONSTRAINT chk_thread_has_suffix CHECK (
  (equipment_type != 'thread_gauge') OR
  (gauge_suffix IN ('A', 'B'))  -- ✅ NOT NULL required for thread gauges
);

-- Constraint: Suffix must match system_gauge_id ending
ALTER TABLE gauges ADD CONSTRAINT chk_suffix_matches_id CHECK (
  gauge_suffix IS NULL OR
  system_gauge_id LIKE CONCAT('%', gauge_suffix)
);

-- NOTE: Bidirectional companion constraint REMOVED (architecturally impossible)
-- Reason: Cannot satisfy during gauge set creation - chicken-and-egg problem
-- Solution: Handle in application code with transaction

-- Constraint: NPT gauges cannot have companions
-- Alternative: Consider handling in application code if this causes issues
-- ALTER TABLE gauges ADD CONSTRAINT chk_npt_no_companion CHECK (
--   (equipment_type != 'thread_gauge') OR
--   (companion_gauge_id IS NOT NULL) OR
--   (category_id != (SELECT id FROM gauge_categories WHERE name = 'NPT' LIMIT 1))
-- );

-- Better approach: Handle NPT validation in domain model

-- ----------------------------------------------------------------------------
-- PHASE 2: SAFE TRIGGERS (Safety Net Only)
-- ----------------------------------------------------------------------------

-- NOTE: Bidirectional companion trigger REMOVED (recursion risk)
-- Reason: Trigger would fire recursively, causing infinite loop or errors
-- Solution: Handle bidirectional linking in service layer within transaction

-- Trigger: Auto-populate gauge_suffix as fallback (safety net)
-- This should rarely activate - service layer should set suffix explicitly
DELIMITER $$
CREATE TRIGGER trg_auto_suffix_insert
BEFORE INSERT ON gauges
FOR EACH ROW
BEGIN
  IF NEW.equipment_type = 'thread_gauge' AND NEW.gauge_suffix IS NULL THEN
    IF NEW.system_gauge_id LIKE '%A' THEN
      SET NEW.gauge_suffix = 'A';
    ELSEIF NEW.system_gauge_id LIKE '%B' THEN
      SET NEW.gauge_suffix = 'B';
    END IF;
  END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER trg_auto_suffix_update
BEFORE UPDATE ON gauges
FOR EACH ROW
BEGIN
  IF NEW.equipment_type = 'thread_gauge' AND NEW.gauge_suffix IS NULL THEN
    IF NEW.system_gauge_id LIKE '%A' THEN
      SET NEW.gauge_suffix = 'A';
    ELSEIF NEW.system_gauge_id LIKE '%B' THEN
      SET NEW.gauge_suffix = 'B';
    END IF;
  END IF;
END$$
DELIMITER ;

-- ----------------------------------------------------------------------------
-- PHASE 3: PERFORMANCE INDEXES
-- ----------------------------------------------------------------------------

-- Index: Find companion pairs efficiently
CREATE INDEX idx_companion_gauge_id ON gauges(companion_gauge_id);

-- Index: Find gauges by suffix
CREATE INDEX idx_gauge_suffix ON gauges(gauge_suffix);

-- Composite index: Optimize spare lookup queries
CREATE INDEX idx_spare_lookup ON gauges(
  equipment_type,
  gauge_suffix,
  companion_gauge_id,
  status
);

-- Composite index: Optimize gauge set queries
CREATE INDEX idx_gauge_set_lookup ON gauges(
  category_id,
  companion_gauge_id,
  status
);

-- ----------------------------------------------------------------------------
-- PHASE 4: FIX EXISTING DATA
-- ----------------------------------------------------------------------------

-- Populate gauge_suffix for existing records
UPDATE gauges
SET gauge_suffix = 'A'
WHERE equipment_type = 'thread_gauge'
  AND gauge_suffix IS NULL
  AND system_gauge_id LIKE '%A';

UPDATE gauges
SET gauge_suffix = 'B'
WHERE equipment_type = 'thread_gauge'
  AND gauge_suffix IS NULL
  AND system_gauge_id LIKE '%B';

-- NOTE: Companion relationships remain NULL and must be re-created
-- through proper service layer with transactions

-- ----------------------------------------------------------------------------
-- VALIDATION QUERIES
-- ----------------------------------------------------------------------------

-- Validate: All thread gauges should have suffix
SELECT
  'Thread gauges without suffix' as check_name,
  COUNT(*) as violation_count
FROM gauges
WHERE equipment_type = 'thread_gauge'
  AND gauge_suffix IS NULL;
-- Expected: 0 after migration

-- Validate: Suffix matches system_gauge_id
SELECT
  'Suffix mismatch with ID' as check_name,
  COUNT(*) as violation_count
FROM gauges
WHERE gauge_suffix IS NOT NULL
  AND system_gauge_id NOT LIKE CONCAT('%', gauge_suffix);
-- Expected: 0 after migration

-- ----------------------------------------------------------------------------
-- ROLLBACK SCRIPT (IN CASE OF ISSUES)
-- ----------------------------------------------------------------------------

/*
-- DROP CONSTRAINTS
ALTER TABLE gauges DROP CONSTRAINT IF EXISTS chk_thread_has_suffix;
ALTER TABLE gauges DROP CONSTRAINT IF EXISTS chk_suffix_matches_id;

-- DROP TRIGGERS
DROP TRIGGER IF EXISTS trg_auto_suffix_insert;
DROP TRIGGER IF EXISTS trg_auto_suffix_update;

-- DROP INDEXES
DROP INDEX IF EXISTS idx_companion_gauge_id ON gauges;
DROP INDEX IF EXISTS idx_gauge_suffix ON gauges;
DROP INDEX IF EXISTS idx_spare_lookup ON gauges;
DROP INDEX IF EXISTS idx_gauge_set_lookup ON gauges;
*/

-- ============================================================================
-- KEY CHANGES FROM ORIGINAL PROPOSAL:
--
-- 1. REMOVED: chk_bidirectional_companion (architecturally impossible)
--    Problem: Chicken-and-egg - first UPDATE always fails CHECK
--    Solution: Handle in application code within transaction
--
-- 2. REMOVED: trg_companion_bidirectional (recursion risk)
--    Problem: Trigger fires recursively, infinite loop
--    Solution: Handle in service layer with explicit updates
--
-- 3. FIXED: chk_thread_has_suffix (now correctly excludes NULL)
--    Was: gauge_suffix IN ('A', 'B', NULL)
--    Now: gauge_suffix IN ('A', 'B')
--
-- 4. REMOVED: chk_npt_no_companion (performance and complexity)
--    Problem: Subquery on every INSERT/UPDATE
--    Solution: Handle in domain model validation
--
-- 5. KEPT: Auto-suffix triggers (safe as fallback)
--    Service layer should still set suffix explicitly
--
-- 6. KEPT: All performance indexes (safe and beneficial)
--
-- ============================================================================
-- WHY BIDIRECTIONAL CONSTRAINT IS IMPOSSIBLE:
--
-- Execution sequence during gauge set creation:
--
-- Step 1: INSERT GO gauge (id=1, companion_gauge_id=NULL)
--   → CHECK: companion_gauge_id IS NULL → ✅ PASS
--
-- Step 2: INSERT NO GO gauge (id=2, companion_gauge_id=NULL)
--   → CHECK: companion_gauge_id IS NULL → ✅ PASS
--
-- Step 3: UPDATE GO gauge SET companion_gauge_id = 2 WHERE id = 1
--   → CHECK: Does gauge 2 point back to gauge 1?
--   → Query: SELECT 1 FROM gauges WHERE id=2 AND companion_gauge_id=1
--   → Result: NO ROWS (gauge 2's companion_gauge_id is still NULL!)
--   → ❌ CONSTRAINT VIOLATION
--   → Transaction rolls back
--   → NO GAUGE SETS CAN BE CREATED
--
-- This is not a timing issue - it's architecturally impossible to satisfy.
-- We cannot set A→B and B→A simultaneously in SQL.
-- ============================================================================
-- END OF MIGRATION
-- ============================================================================
```

---

## Domain Model Design

### GaugeSet Aggregate Root

```javascript
// backend/src/modules/gauge/domain/GaugeSet.js

const DomainValidationError = require('./DomainValidationError');

class GaugeSet {
  constructor({ baseId, goGauge, noGoGauge, category }) {
    this.baseId = baseId;
    this.goGauge = goGauge;
    this.noGoGauge = noGoGauge;
    this.category = category;

    this.validate();
  }

  validate() {
    // Business Rule: Companion gauges must have matching specifications
    if (!this.specificationsMatch()) {
      throw new DomainValidationError(
        'Companion gauges must have matching thread size, class, and type',
        'SPEC_MISMATCH',
        {
          goSpecs: {
            size: this.goGauge.threadSize,
            class: this.goGauge.threadClass,
            type: this.goGauge.threadType
          },
          noGoSpecs: {
            size: this.noGoGauge.threadSize,
            class: this.noGoGauge.threadClass,
            type: this.noGoGauge.threadType
          }
        }
      );
    }

    // Business Rule: NPT gauges cannot have companion pairs
    if (this.category.name === 'NPT') {
      throw new DomainValidationError(
        'NPT gauges cannot have companion pairs',
        'NPT_NO_COMPANION'
      );
    }

    // Business Rule: GO gauge must have suffix 'A'
    if (this.goGauge.suffix !== 'A') {
      throw new DomainValidationError(
        'GO gauge must have suffix A',
        'INVALID_GO_SUFFIX'
      );
    }

    // Business Rule: NO GO gauge must have suffix 'B'
    if (this.noGoGauge.suffix !== 'B') {
      throw new DomainValidationError(
        'NO GO gauge must have suffix B',
        'INVALID_NOGO_SUFFIX'
      );
    }
  }

  specificationsMatch() {
    return (
      this.goGauge.threadSize === this.noGoGauge.threadSize &&
      this.goGauge.threadClass === this.noGoGauge.threadClass &&
      this.goGauge.threadType === this.noGoGauge.threadType
    );
  }

  toDatabase() {
    return {
      goGauge: {
        ...this.goGauge.toDatabase(),
        system_gauge_id: `${this.baseId}A`,
        gauge_id: `${this.baseId}A`,
        gauge_suffix: 'A'
      },
      noGoGauge: {
        ...this.noGoGauge.toDatabase(),
        system_gauge_id: `${this.baseId}B`,
        gauge_id: `${this.baseId}B`,
        gauge_suffix: 'B'
      }
    };
  }
}

module.exports = GaugeSet;
```

### GaugeEntity Value Object

```javascript
// backend/src/modules/gauge/domain/GaugeEntity.js

const DomainValidationError = require('./DomainValidationError');

class GaugeEntity {
  constructor(data) {
    this.id = data.id;
    this.systemGaugeId = data.system_gauge_id;
    this.gaugeSuffix = data.gauge_suffix;
    this.description = data.description;
    this.equipmentType = data.equipment_type;
    this.manufacturer = data.manufacturer;
    this.categoryId = data.category_id;
    this.status = data.status;
    this.companionGaugeId = data.companion_gauge_id;

    // Thread specification fields
    this.threadSize = data.thread_size;
    this.threadClass = data.thread_class;
    this.threadType = data.thread_type;

    this.validate();
  }

  validate() {
    if (!this.systemGaugeId) {
      throw new DomainValidationError('system_gauge_id is required');
    }

    if (this.equipmentType === 'thread_gauge' && !this.threadSize) {
      throw new DomainValidationError('thread_size is required for thread gauges');
    }
  }

  get suffix() {
    return this.gaugeSuffix;
  }

  toDatabase() {
    return {
      system_gauge_id: this.systemGaugeId,
      gauge_suffix: this.gaugeSuffix,
      description: this.description,
      equipment_type: this.equipmentType,
      manufacturer: this.manufacturer,
      category_id: this.categoryId,
      status: this.status,
      companion_gauge_id: this.companionGaugeId,
      thread_size: this.threadSize,
      thread_class: this.threadClass,
      thread_type: this.threadType
    };
  }
}

module.exports = GaugeEntity;
```

### DomainValidationError

```javascript
// backend/src/modules/gauge/domain/DomainValidationError.js

class DomainValidationError extends Error {
  constructor(message, code, metadata = {}) {
    super(message);
    this.name = 'DomainValidationError';
    this.code = code;
    this.metadata = metadata;
  }
}

module.exports = DomainValidationError;
```

---

## Repository Pattern

### Key Principles

1. **Explicit Transaction Requirement**: All write methods MUST receive connection
2. **No Transaction Management**: Repository doesn't manage transactions
3. **Single Responsibility**: Data access only, no business logic

### GaugeRepository (Refactored)

```javascript
// backend/src/modules/gauge/repositories/GaugeRepository.js

class GaugeRepository extends BaseRepository {

  // ✅ CORRECT: Explicit connection requirement
  async createWithinTransaction(gaugeData, connection) {
    if (!connection) {
      throw new Error('createWithinTransaction requires connection parameter');
    }

    const query = `
      INSERT INTO gauges (
        system_gauge_id, gauge_suffix, description, equipment_type,
        manufacturer, category_id, status, created_by, thread_size,
        thread_class, thread_type
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    const params = [
      gaugeData.system_gauge_id,
      gaugeData.gauge_suffix,  // ✅ Explicitly set
      gaugeData.description,
      gaugeData.equipment_type,
      gaugeData.manufacturer,
      gaugeData.category_id,
      gaugeData.status || 'available',
      gaugeData.created_by,
      gaugeData.thread_size,
      gaugeData.thread_class,
      gaugeData.thread_type
    ];

    const result = await this.executeQuery(query, params, connection);
    return { id: result.insertId, ...gaugeData };
  }

  // ✅ CORRECT: Explicit connection requirement
  async linkCompanionsWithinTransaction(gaugeId1, gaugeId2, connection) {
    if (!connection) {
      throw new Error('linkCompanionsWithinTransaction requires connection parameter');
    }

    // Validation: Ensure both gauges exist
    const gauges = await this.executeQuery(
      'SELECT id, equipment_type FROM gauges WHERE id IN (?, ?)',
      [gaugeId1, gaugeId2],
      connection
    );

    if (gauges.length !== 2) {
      throw new Error('Both gauges must exist to link as companions');
    }

    // Update both gauges in single transaction
    await this.executeQuery(
      'UPDATE gauges SET companion_gauge_id = ? WHERE id = ?',
      [gaugeId2, gaugeId1],
      connection  // ✅ Explicit connection passing
    );

    await this.executeQuery(
      'UPDATE gauges SET companion_gauge_id = ? WHERE id = ?',
      [gaugeId1, gaugeId2],
      connection  // ✅ Explicit connection passing
    );
  }

  // ✅ CORRECT: Read operations can use default connection
  async findSpares(filters = {}) {
    const conditions = [];
    const params = [];

    // Spares are gauges without companions
    conditions.push('companion_gauge_id IS NULL');

    if (filters.equipmentType) {
      conditions.push('equipment_type = ?');
      params.push(filters.equipmentType);
    }

    if (filters.gaugeSuffix) {
      conditions.push('gauge_suffix = ?');
      params.push(filters.gaugeSuffix);
    }

    const query = `
      SELECT * FROM gauges
      WHERE ${conditions.join(' AND ')}
      ORDER BY system_gauge_id
    `;

    return this.executeQuery(query, params);
  }
}
```

---

## Service Layer

### GaugeSetService

```javascript
// backend/src/modules/gauge/services/GaugeSetService.js

const BaseService = require('../../../infrastructure/services/BaseService');
const GaugeRepository = require('../repositories/GaugeRepository');
const GaugeSet = require('../domain/GaugeSet');
const GaugeEntity = require('../domain/GaugeEntity');

class GaugeSetService extends BaseService {
  constructor() {
    super('gauges');
    this.gaugeRepository = new GaugeRepository();
  }

  /**
   * Create a gauge set (GO + NO GO pair)
   * @param {Object} goData - GO gauge data
   * @param {Object} noGoData - NO GO gauge data
   * @param {number} userId - User creating the set
   * @returns {Promise<Object>} Created gauge set
   */
  async createGaugeSet(goData, noGoData, userId) {
    return this.executeInTransaction(async (connection) => {

      // 1. Get next gauge ID
      const baseId = await this.gaugeRepository.getNextGaugeId(connection);

      // 2. Create domain objects
      const goGauge = new GaugeEntity({
        ...goData,
        gauge_suffix: 'A',  // ✅ Explicitly set
        system_gauge_id: `${baseId}A`,
        created_by: userId
      });

      const noGoGauge = new GaugeEntity({
        ...noGoData,
        gauge_suffix: 'B',  // ✅ Explicitly set
        system_gauge_id: `${baseId}B`,
        created_by: userId
      });

      // 3. Create GaugeSet aggregate (validates business rules)
      const gaugeSet = new GaugeSet({
        baseId,
        goGauge,
        noGoGauge,
        category: goData.category
      });

      // 4. Convert to database format
      const dbData = gaugeSet.toDatabase();

      // 5. Create both gauges within transaction
      const createdGo = await this.gaugeRepository.createWithinTransaction(
        dbData.goGauge,
        connection  // ✅ Explicit connection passing
      );

      const createdNoGo = await this.gaugeRepository.createWithinTransaction(
        dbData.noGoGauge,
        connection  // ✅ Explicit connection passing
      );

      // 6. Link companions within same transaction
      await this.gaugeRepository.linkCompanionsWithinTransaction(
        createdGo.id,
        createdNoGo.id,
        connection  // ✅ Explicit connection passing
      );

      // 7. Record in companion history
      await this.gaugeRepository.recordCompanionHistory(
        createdGo.id,
        createdNoGo.id,
        'created_together',
        userId,
        connection  // ✅ Explicit connection passing
      );

      // 8. Return complete set
      return {
        baseId,
        goGauge: await this.gaugeRepository.findById(createdGo.id),
        noGoGauge: await this.gaugeRepository.findById(createdNoGo.id)
      };
    });
  }

  /**
   * Create gauge set from existing spares
   * @param {number} goGaugeId - Existing GO gauge (spare)
   * @param {number} noGoGaugeId - Existing NO GO gauge (spare)
   * @param {number} userId - User performing pairing
   * @returns {Promise<Object>} Paired gauge set
   */
  async pairSpares(goGaugeId, noGoGaugeId, userId) {
    return this.executeInTransaction(async (connection) => {

      // 1. Fetch both gauges
      const goGauge = await this.gaugeRepository.findById(goGaugeId);
      const noGoGauge = await this.gaugeRepository.findById(noGoGaugeId);

      // 2. Validate both are spares (no companion)
      if (goGauge.companion_gauge_id || noGoGauge.companion_gauge_id) {
        throw new Error('Both gauges must be spares (no existing companion)');
      }

      // 3. Create domain objects
      const goEntity = new GaugeEntity(goGauge);
      const noGoEntity = new GaugeEntity(noGoGauge);

      // 4. Validate as set (this enforces matching specs)
      const gaugeSet = new GaugeSet({
        baseId: goGauge.system_gauge_id.replace(/[AB]$/, ''),
        goGauge: goEntity,
        noGoGauge: noGoEntity,
        category: goGauge.category
      });

      // 5. Link companions
      await this.gaugeRepository.linkCompanionsWithinTransaction(
        goGaugeId,
        noGoGaugeId,
        connection
      );

      // 6. Record in history
      await this.gaugeRepository.recordCompanionHistory(
        goGaugeId,
        noGoGaugeId,
        'paired_from_spares',
        userId,
        connection
      );

      return {
        goGauge: await this.gaugeRepository.findById(goGaugeId),
        noGoGauge: await this.gaugeRepository.findById(noGoGaugeId)
      };
    });
  }
}

module.exports = GaugeSetService;
```

---

## Implementation Roadmap

### Phase 1: Database Schema

**Tasks**:
- [ ] Apply corrected migration `002_gauge_set_constraints_CORRECTED.sql`
- [ ] Test CHECK constraints enforcement
- [ ] Test auto-suffix triggers
- [ ] Verify performance indexes created
- [ ] Run validation queries (expect 0 violations)

**Acceptance Criteria**:
- ✅ Cannot insert thread gauge without valid suffix ('A' or 'B')
- ✅ Suffix auto-populates from system_gauge_id as fallback
- ✅ All indexes created and used by queries
- ✅ Validation queries return 0 violations

---

### Phase 2: Domain Model

**Tasks**:
- [ ] Create `backend/src/modules/gauge/domain/DomainValidationError.js`
- [ ] Create `backend/src/modules/gauge/domain/GaugeEntity.js`
- [ ] Create `backend/src/modules/gauge/domain/GaugeSet.js`
- [ ] Write unit tests for all domain logic
- [ ] Verify 100% domain coverage

**Acceptance Criteria**:
- ✅ GaugeSet validates matching specifications
- ✅ GaugeSet rejects NPT pairs with clear error
- ✅ GaugeSet enforces correct suffixes
- ✅ GaugeEntity validates required fields
- ✅ 100% test coverage for domain layer

---

### Phase 3: Repository Refactor

**Tasks**:
- [ ] Rename `create()` → `createWithinTransaction(data, connection)`
- [ ] Rename `updateCompanionGauges()` → `linkCompanionsWithinTransaction(id1, id2, connection)`
- [ ] Add connection validation (throw if missing)
- [ ] Fix all `executeQuery()` calls to pass connection parameter
- [ ] Write integration tests for transaction rollback

**Acceptance Criteria**:
- ✅ All write methods require connection parameter
- ✅ Missing connection throws descriptive error
- ✅ Integration tests verify transaction rollback works
- ✅ `gauge_suffix` field populated on create

---

### Phase 4: Service Layer

**Tasks**:
- [ ] Create `backend/src/modules/gauge/services/GaugeSetService.js`
- [ ] Implement `createGaugeSet(goData, noGoData, userId)`
- [ ] Implement `pairSpares(goGaugeId, noGoGaugeId, userId)`
- [ ] Update API routes to use new service
- [ ] Write integration tests for all workflows

**Acceptance Criteria**:
- ✅ createGaugeSet creates both gauges with correct suffixes
- ✅ createGaugeSet links companions bidirectionally
- ✅ pairSpares validates matching specifications
- ✅ All operations atomic (rollback on error)

---

### Phase 5: Testing

**Tasks**:
- [ ] Domain model unit tests (100% coverage)
- [ ] Repository integration tests
- [ ] Service integration tests
- [ ] API endpoint tests
- [ ] Generate coverage report (≥90%)

**Acceptance Criteria**:
- ✅ 90%+ overall code coverage
- ✅ 100% domain model coverage
- ✅ All happy paths tested
- ✅ All error scenarios tested
- ✅ Transaction rollback scenarios tested

---

### Phase 6: Frontend Integration

**Tasks**:
- [ ] Update `CreateGaugeWorkflow.tsx` to use new API
- [ ] Create `SpareInventoryPanel.tsx` component
- [ ] Create `PairSparesModal.tsx` component
- [ ] Update `GaugeDetail.tsx` to show companion info
- [ ] Write E2E tests with Playwright

**Acceptance Criteria**:
- ✅ Can create gauge set with GO/NO GO distinction visible
- ✅ Spares display shows available orphaned gauges
- ✅ Can pair spares through UI
- ✅ Companion relationships display correctly
- ✅ Error messages user-friendly

---

## Acceptance Criteria

### Overall System

1. **Gauge Set Creation**:
   - ✅ Creates both GO and NO GO gauges atomically
   - ✅ Both gauges have correct `gauge_suffix` ('A' and 'B')
   - ✅ Both gauges linked bidirectionally via `companion_gauge_id`
   - ✅ Transaction rollback on any error

2. **Spare Management**:
   - ✅ Spares query efficient (uses suffix index)
   - ✅ Can filter spares by suffix (A or B)
   - ✅ Can pair compatible spares into set
   - ✅ Pairing validates matching specifications

3. **Data Integrity**:
   - ✅ Database constraints prevent invalid states
   - ✅ Triggers maintain suffix consistency
   - ✅ Thread gauges must have valid suffix
   - ✅ NPT validation in domain model

4. **Code Quality**:
   - ✅ Explicit transaction boundaries
   - ✅ Domain logic in domain objects
   - ✅ Repository does data access only
   - ✅ Service orchestrates transactions
   - ✅ 90%+ test coverage

---

## Migration Strategy

### From Current Broken State

1. **Database Migration**:
   ```bash
   mysql -h localhost -P 3307 -u root -p fai_db_sandbox < 002_gauge_set_constraints_CORRECTED.sql
   ```

2. **Code Deployment**:
   - Deploy domain model files
   - Deploy refactored repository
   - Deploy new service layer
   - Update API routes
   - Deploy frontend updates
   - Restart Docker containers: `docker-compose restart backend frontend`

3. **Verification**:
   ```bash
   # Run all tests
   npm test

   # Run E2E tests
   npm run test:e2e

   # Manual verification
   # 1. Create gauge set via UI
   # 2. Verify both gauges in database with correct suffix
   # 3. Verify companion_gauge_id bidirectional
   ```

### Success Metrics

**Database Validation**:
```sql
-- All thread gauges should have suffix
SELECT COUNT(*) FROM gauges
WHERE equipment_type = 'thread_gauge' AND gauge_suffix IS NULL;
-- Expected: 0

-- All companion relationships should be bidirectional
SELECT COUNT(*) FROM gauges g1
WHERE companion_gauge_id IS NOT NULL
AND NOT EXISTS (
  SELECT 1 FROM gauges g2
  WHERE g2.id = g1.companion_gauge_id
  AND g2.companion_gauge_id = g1.id
);
-- Expected: 0
```

**Functional Testing**:
- Create 10 gauge sets successfully
- All 20 gauges have correct suffix
- All 20 gauges have bidirectional companion links
- Create 5 spares and pair 4 of them
- Spare queries filter correctly by suffix

---

## Rollback Plan

**If Critical Issues Arise**:

1. **Stop Services**:
   ```bash
   docker-compose stop backend frontend
   ```

2. **Rollback Database**:
   ```sql
   -- Run rollback script from migration file
   ALTER TABLE gauges DROP CONSTRAINT chk_thread_has_suffix;
   ALTER TABLE gauges DROP CONSTRAINT chk_suffix_matches_id;
   DROP TRIGGER trg_auto_suffix_insert;
   DROP TRIGGER trg_auto_suffix_update;
   DROP INDEX idx_companion_gauge_id ON gauges;
   DROP INDEX idx_gauge_suffix ON gauges;
   DROP INDEX idx_spare_lookup ON gauges;
   DROP INDEX idx_gauge_set_lookup ON gauges;
   ```

3. **Rollback Code**:
   ```bash
   git revert <commit-hash>
   ```

4. **Restart Services**:
   ```bash
   docker-compose up -d backend frontend
   ```

---

## Notes

### Development Phase Advantages
- Can break existing code without compatibility concerns
- Can restructure database without production data migration
- Can implement ideal architecture from scratch
- Test data only - no production impact

### Key Architectural Decisions
1. **Explicit Transactions**: Clarity over convenience
2. **Domain-Driven**: Business rules in domain objects
3. **Safe Database Constraints**: Simple validation only
4. **Application-Side Validation**: Complex business rules in code
5. **Single Responsibility**: Each layer does ONE thing

### Why This is a Clean Solution
1. **Prevents Bug Classes**: Impossible to violate transaction boundaries
2. **Self-Documenting**: Method names clearly state requirements
3. **Database Integrity**: Constraints enforce simple rules
4. **Type Safety**: Domain objects enforce complex business rules
5. **Testable**: Each layer independently testable

---

**END OF PLAN**
